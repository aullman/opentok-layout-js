{"version":3,"sources":["webpack://initLayoutContainer/webpack/universalModuleDefinition","webpack://initLayoutContainer/webpack/bootstrap","webpack://initLayoutContainer/./src/getLayout.ts","webpack://initLayoutContainer/./src/index.ts","webpack://initLayoutContainer/./src/layout.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","getBestDimensions","minRatio","maxRatio","Width","Height","count","maxWidth","maxHeight","evenRows","maxArea","targetCols","targetRows","targetHeight","targetWidth","tWidth","tHeight","tRatio","cols","rows","Math","ceil","floor","area","min","undefined","ratio","getLayout","opts","elements","dimensions","fixedRatio","containerWidth","containerHeight","offsetLeft","offsetTop","alignItems","Infinity","scaleLastRow","ratios","map","element","height","width","length","row","x","y","boxes","push","totalRowHeight","remainingShortRows","remainingHeightDiff","extraHeight","rowMarginLeft","j","left","top","bigPercentage","minBigPercentage","bigFixedRatio","bigMaxRatio","bigMinRatio","bigFirst","bigAlignItems","smallAlignItems","smallMaxWidth","smallMaxHeight","bigMaxWidth","bigMaxHeight","bigScaleLastRow","availableRatio","bigOffsetTop","bigOffsetLeft","bigIndices","bigOnes","filter","idx","big","smallOnes","bigBoxes","smallBoxes","areas","bigWidth","bigHeight","showBigFirst","bigDimensions","max","forEach","box","small","bigBoxesIdx","smallBoxesIdx","indexOf","container","win","window","document","querySelector","HTMLElement","layout","css","el","propertyName","style","NaN","keys","currentValue","getComputedStyle","getPropertyValue","getCSSNumber","elem","prop","cssStr","parseInt","animate","bigClass","ignoreClass","fixedRatioClass","heightStr","id","getAttribute","random","toFixed","setAttribute","offsetHeight","widthStr","offsetWidth","getWidth","children","Array","querySelectorAll","child","videoHeight","videoWidth","video","getChildDims","classList","contains","actualWidth","actualHeight","w","h","onLayout","targetPosition","fixAspectRatio","sub","oldWidth","$","stop","duration","easing","complete","add","positionElement"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAA6B,oBAAID,IAEjCD,EAA0B,oBAAIC,IARhC,CASmB,oBAATK,KAAuBA,KAAOC,MAAM,WAC9C,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUR,QAGnC,IAAIC,EAASK,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHV,QAAS,IAUV,OANAW,EAAQH,GAAUI,KAAKX,EAAOD,QAASC,EAAQA,EAAOD,QAASO,GAG/DN,EAAOS,GAAI,EAGJT,EAAOD,QA0Df,OArDAO,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASf,EAASgB,EAAMC,GAC3CV,EAAoBW,EAAElB,EAASgB,IAClCG,OAAOC,eAAepB,EAASgB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAASvB,GACX,oBAAXwB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAepB,EAASwB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAepB,EAAS,aAAc,CAAE0B,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASjC,GAChC,IAAIgB,EAAShB,GAAUA,EAAO4B,WAC7B,WAAwB,OAAO5B,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAM,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,+CC9ErD,IAAMC,EAAoB,SAACC,EAAkBC,EAAkBC,EAAeC,EAAgBC,EAAeC,EAAkBC,EAAmBC,GAYhJ,IAXA,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAIKhD,EAAI,EAAGA,GAAKqC,EAAOrC,GAAK,EAAG,CAClC,IAAMiD,EAAOjD,EACPkD,EAAOC,KAAKC,KAAKf,EAAQY,IAM/BD,GAHAD,EAAUI,KAAKE,MAAMjB,EAASc,KAC9BJ,EAASK,KAAKE,MAAMlB,EAAQc,KAGff,EAGXa,EAAUD,GADVE,EAASd,GAEAc,EAASf,IAGlBa,EAASC,GADTC,EAASf,IAOX,IAAMqB,GAHNR,EAASK,KAAKI,IAAIjB,EAAUQ,KAC5BC,EAAUI,KAAKI,IAAIhB,EAAWQ,IAEIV,EAGlC,QAAgBmB,IAAZf,GAA0Ba,GAAQb,EAAU,CAC9C,GAAID,GAAYc,IAASb,GAAaQ,EAAOC,EAAQb,EAAWM,EAAaD,EAAcL,EAGzF,SAEFI,EAAUa,EACVV,EAAeG,EACfF,EAAcC,EACdJ,EAAaO,EACbN,EAAaO,GAGjB,MAAO,CACLT,QAAO,EACPC,WAAU,EACVC,WAAU,EACVC,aAAY,EACZC,YAAW,EACXY,MAAOb,EAAeC,IAkBpBa,EAAY,SAACC,EAAyBC,GAExC,IAiBEC,EAjBF3B,EAYEyB,EAAI,SAXN1B,EAWE0B,EAAI,SAVNG,EAUEH,EAAI,WATNI,EASEJ,EAAI,eARNK,EAQEL,EAAI,gBAPN,EAOEA,EAAI,WAPNM,OAAU,IAAG,IAAC,EACd,EAMEN,EAAI,UANNO,OAAS,IAAG,IAAC,EACb,EAKEP,EAAI,WALNQ,OAAU,IAAG,WAAQ,EACrB,EAIER,EAAI,SAJNrB,OAAQ,IAAG,EAAA8B,IAAQ,EACnB,EAGET,EAAI,UAHNpB,OAAS,IAAG,EAAA6B,IAAQ,EACpB,EAEET,EAAI,aAFNU,OAAY,IAAG,GAAI,EACnB,EACEV,EAAI,SADNnB,OAAQ,IAAG,GAAI,EAEX8B,EAASV,EAASW,KAAI,SAAAC,GAAW,OAAAA,EAAQC,OAASD,EAAQE,SAC1DrC,EAAQiC,EAAOK,OAKrB,GAAKb,EAGE,CAEL,IAAML,EAAQa,EAAOK,OAAS,EAAIL,EAAO,GAAK,KAC9CT,EAAa7B,EAAkByB,EAAOA,EAAOM,EAAgBC,EAAiB3B,EAC5EC,EAAUC,EAAWC,QANvBqB,EAAa7B,EAAkBC,EAAUC,EAAU6B,EAAgBC,EAAiB3B,EAClFC,EAAUC,EAAWC,GAiBzB,IARA,IAGIoC,EAHAC,EAAI,EACJC,EAAI,EACF5B,EAAc,GAEd6B,EAAe,GAIZ/E,EAAI,EAAGA,EAAIsE,EAAOK,OAAQ3E,GAAK,EAAG,CACrCA,EAAI6D,EAAWnB,YAAe,IAEhCkC,EAAM,CACJN,OAAQ,GACRV,SAAU,GACVc,MAAO,EACPD,OAAQ,GAEVvB,EAAK8B,KAAKJ,IAENnB,EAAQa,EAAOtE,GAArB,IACMwE,EAAUZ,EAAS5D,GACzB4E,EAAIhB,SAASoB,KAAKR,GAClBI,EAAIN,OAAOU,KAAKvB,GAChB,IAAIZ,EAAcgB,EAAWhB,YACvBD,EAAeiB,EAAWjB,cAE5BkB,GAAcU,EAAQV,cACxBjB,EAAcD,EAAea,GAE/BmB,EAAIF,OAAS7B,EACb+B,EAAIH,OAAS7B,EAGf,IAAIqC,EAAiB,EACjBC,EAAqB,EACzB,IAASlF,EAAI,EAAGA,EAAIkD,EAAKyB,OAAQ3E,GAAK,GACpC4E,EAAM1B,EAAKlD,IACH0E,MAAQX,GAEda,EAAIH,OAAStB,KAAKE,MAAMuB,EAAIH,QAAUV,EAAiBa,EAAIF,QAC3DE,EAAIF,MAAQX,GACHa,EAAIF,MAAQX,GAAkBa,EAAIH,OAASlC,IACpD2C,GAAsB,GAExBD,GAAkBL,EAAIH,OAExB,GAAIJ,GAAgBY,EAAiBjB,GAAmBkB,EAAqB,EAAG,CAE9E,IAAIC,EAAsBnB,EAAkBiB,EAC5CA,EAAiB,EACjB,IAASjF,EAAI,EAAGA,EAAIkD,EAAKyB,OAAQ3E,GAAK,EAAG,CAEvC,IADA4E,EAAM1B,EAAKlD,IACH0E,MAAQX,EAAgB,CAE9B,IAAIqB,EAAcD,EAAsBD,EACnCE,EAAcR,EAAIH,QAAYV,EAAiBa,EAAIF,OAASE,EAAIF,QAEnEU,EAAcjC,KAAKE,OAAQU,EAAiBa,EAAIF,OAASE,EAAIF,MAASE,EAAIH,SAE5EG,EAAIF,OAASvB,KAAKE,MAAO+B,EAAcR,EAAIH,OAAUG,EAAIF,OACzDE,EAAIH,QAAUW,EACdD,GAAuBC,EACvBF,GAAsB,EAExBD,GAAkBL,EAAIH,QAG1B,OAAQN,GACN,IAAK,QACHW,EAAI,EACJ,MACF,IAAK,MACHA,EAAId,EAAkBiB,EACtB,MACF,IAAK,SACL,QACEH,GAAMd,EAAkB,GAAoB,EAIhD,IAAShE,EAAI,EAAGA,EAAIkD,EAAKyB,OAAQ3E,GAAK,EAAG,CACvC4E,EAAM1B,EAAKlD,GACX,IAAIqF,OAAa,EACjB,OAAQlB,GACN,IAAK,QACHkB,EAAgB,EAChB,MACF,IAAK,MACHA,EAAgBtB,EAAiBa,EAAIF,MACrC,MACF,IAAK,SACL,QACEW,GAAkBtB,EAAiBa,EAAIF,OAAS,EAGpDG,EAAIQ,EACAzC,OAAY,EAChB,IADA,IACS0C,EAAI,EAAGA,EAAIV,EAAIN,OAAOK,OAAQW,GAAK,EAAG,CACvC7B,EAAQmB,EAAIN,OAAOgB,GACnBd,EAAUI,EAAIhB,SAAS0B,GAEzBzC,EAAcgB,EAAWhB,YAC7BD,EAAegC,EAAIH,OAEfX,GAAcU,EAAQV,WACxBjB,EAAcM,KAAKE,MAAMT,EAAea,GAC9Bb,EAAeC,GACpBgB,EAAWjB,aAAeiB,EAAWhB,cAE1CA,EAAcM,KAAKE,MAAOQ,EAAWhB,YAAcgB,EAAWjB,aAAgBA,IAGhFmC,EAAMC,KAAK,CACTO,KAAMV,EAAIZ,EACVuB,IAAKV,EAAIZ,EACTQ,MAAO7B,EACP4B,OAAQ7B,IAEViC,GAAKhC,EAEPiC,GAAKlC,EAEP,OAAOmC,GAKT,mBAAgBpB,EAAeC,GAE3B,IAJmBY,EAInB,EAuBEb,EAAI,SAvBNzB,OAAQ,IAAG,MAAK,EAChB,EAsBEyB,EAAI,SAtBN1B,OAAQ,IAAG,IAAI,GAAE,EACjB,EAqBE0B,EAAI,WArBNG,OAAU,IAAG,GAAK,EAClB,EAoBEH,EAAI,cApBN8B,OAAa,IAAG,KAAG,EACnB,EAmBE9B,EAAI,iBAnBN+B,OAAgB,IAAG,IAAC,EACpB,EAkBE/B,EAAI,cAlBNgC,OAAa,IAAG,GAAK,EACrB,EAiBEhC,EAAI,YAjBNiC,OAAW,IAAG,MAAK,EACnB,EAgBEjC,EAAI,YAhBNkC,OAAW,IAAG,IAAI,GAAE,EACpB,EAeElC,EAAI,SAfNmC,OAAQ,IAAG,GAAI,EACf,EAcEnC,EAAI,eAdNI,OAAc,IAAG,MAAG,EACpB,EAaEJ,EAAI,gBAbNK,OAAe,IAAG,MAAG,EACrB,EAYEL,EAAI,WAZNQ,OAAU,IAAG,WAAQ,EACrB,EAWER,EAAI,cAXNoC,OAAa,IAAG,WAAQ,EACxB,EAUEpC,EAAI,gBAVNqC,OAAe,IAAG,WAAQ,EAC1B,EASErC,EAAI,SATNrB,OAAQ,IAAG,EAAA8B,IAAQ,EACnB,EAQET,EAAI,UARNpB,OAAS,IAAG,EAAA6B,IAAQ,EACpB,EAOET,EAAI,cAPNsC,OAAa,IAAG,EAAA7B,IAAQ,EACxB,EAMET,EAAI,eANNuC,OAAc,IAAG,EAAA9B,IAAQ,EACzB,EAKET,EAAI,YALNwC,OAAW,IAAG,EAAA/B,IAAQ,EACtB,EAIET,EAAI,aAJNyC,OAAY,IAAG,EAAAhC,IAAQ,EACvB,EAGET,EAAI,aAHNU,OAAY,IAAG,GAAI,EACnB,EAEEV,EAAI,gBAFN0C,OAAe,IAAG,GAAI,EACtB,EACE1C,EAAI,SADNnB,OAAQ,IAAG,GAAI,EAGX8D,EAAiBtC,EAAkBD,EACrCE,EAAa,EACbC,EAAY,EACZqC,GAAe,EACfC,GAAgB,EACdC,GAAuB,GACvBC,GAAU9C,EAAS+C,QAAO,SAACnC,EAASoC,GACxC,QAAIpC,EAAQqC,MACVJ,GAAWzB,KAAK4B,IACT,MAILE,GAAYlD,EAAS+C,QAAO,SAAAnC,GAAW,OAACA,EAAQqC,OAClDE,GAAkB,GAClBC,GAAoB,GAClBC,GAAe,GACrB,GAAIP,GAAQ/B,OAAS,GAAKmC,GAAUnC,OAAS,EAAG,CAC9C,IAAIuC,QAAQ,EACRC,QAAS,EACTC,IAA4B,IAAbtB,EAEnB,GAAIQ,GAnDe9B,EAmDgBkC,GAAQ,IAnDKjC,OAASD,EAAQE,MAmDjB,CAK9C,GAFAwC,GAAWnD,EACXoD,GAAYhE,KAAKE,MAAMW,EAAkByB,GACrCC,EAAmB,EAAG,CAExB,IAAI2B,QAAa,EACjB,GAAK1B,EAGE,CAEL,IAAMlC,GAAQiD,GAAQ,GAAGjC,OAASiC,GAAQ,GAAGhC,MAC7C2C,GAAgBrF,EAAkByB,GAAOA,GAAOyD,GAAUC,GACxDT,GAAQ/B,OAAQwB,EAAaC,EAAc5D,QAN7C6E,GAAgBrF,EAAkB6D,EAAaD,EAAasB,GAC1DC,GAAWT,GAAQ/B,OAAQwB,EAAaC,EAAc5D,GAO1D2E,GAAYhE,KAAKmE,IAAItD,EAAkB0B,EACrCvC,KAAKI,IAAI4D,GAAWE,GAAczE,aAAeyE,GAAc1E,aAGjE,IAAM,GAAae,EAAU,CAC3BK,eAAgBA,EAChBC,gBAAiBA,EAAkBmD,GACnClD,WAAY,EACZC,UAAW,EACXJ,WAAU,EACV7B,SAAQ,EACRC,SAAQ,EACRiC,WAAY6B,EACZ1D,SAAU2D,EACV1D,UAAW2D,EACX7B,aAAY,EACZ7B,SAAQ,GACPsE,IACC,GAAc,EACd,QAAatD,EACjB,GAAW+D,SAAQ,SAAAC,GACb,KAAeA,EAAIhC,MACrB,GAAagC,EAAIhC,IACjB,IAAegC,EAAI/C,WAGvB0C,GAAYhE,KAAKmE,IAAIH,GAAWnD,EAAkB,IAGpDuC,GAAevC,GADfE,EAAYiD,IAEK,WAAbrB,EACFsB,IAAe,EACO,QAAbtB,IACTsB,IAAe,OAEZ,CAKL,GAFAD,GAAYnD,EACZkD,GAAW/D,KAAKE,MAAMU,EAAiB0B,GACnCC,EAAmB,EAAG,CAEpB2B,QAAa,EACjB,GAAK1B,EAGE,CAEClC,GAAQiD,GAAQ,GAAGjC,OAASiC,GAAQ,GAAGhC,MAC7C2C,GAAgBrF,EAAkByB,GAAOA,GAAOyD,GAAUC,GACxDT,GAAQ/B,OAAQwB,EAAaC,EAAc5D,QAN7C6E,GAAgBrF,EAAkB6D,EAAaD,EAAasB,GAC1DC,GAAWT,GAAQ/B,OAAQwB,EAAaC,EAAc5D,GAO1D0E,GAAW/D,KAAKmE,IAAIvD,EAAiB2B,EACnCvC,KAAKI,IAAI2D,GAAUG,GAAcxE,YAAcwE,GAAc3E,aAG/D,IAAM,GAAagB,EAAU,CAC3BK,eAAgBA,EAAiBmD,GACjClD,gBAAiBA,EACjBC,WAAY,EACZC,UAAW,EACXJ,WAAU,EACV7B,SAAQ,EACRC,SAAQ,EACRiC,WAAY6B,EACZ1D,SAAU2D,EACV1D,UAAW2D,EACX7B,aAAY,EACZ7B,SAAQ,GACPsE,IACC,GAAa,EACb,GAAe,EACf,GAAM,EACV,GAAWS,SAAQ,SAAAC,GACbA,EAAIhC,MAAQ,KACd,GAAe,EACf,GAAMgC,EAAIhC,KAEZ,IAAgBgC,EAAI9C,MACpB,GAAavB,KAAKmE,IAAI,GAAY,OAEpCJ,GAAW/D,KAAKmE,IAAIJ,GAAUnD,EAAiB,IAGjDyC,GAAgBzC,GADhBE,EAAaiD,IAEI,WAAbpB,EACFsB,IAAe,EACO,QAAbtB,IACTsB,IAAe,GAGfA,IACFH,GAAMJ,IAAM,CACVrB,IAAK,EACLD,KAAM,EACNb,MAAOwC,GACPzC,OAAQ0C,IAEVF,GAAMQ,MAAQ,CACZjC,IAAKtB,EACLqB,KAAMtB,EACNS,MAAOX,EAAiBE,EACxBQ,OAAQT,EAAkBE,KAG5B+C,GAAMJ,IAAM,CACVtB,KAAMiB,GACNhB,IAAKe,GACL7B,MAAOwC,GACPzC,OAAQ0C,IAEVF,GAAMQ,MAAQ,CACZjC,IAAK,EACLD,KAAM,EACNb,MAAOX,EAAiBE,EACxBQ,OAAQT,EAAkBE,SAGrBwC,GAAQ/B,OAAS,GAA0B,IAArBmC,GAAUnC,OAEzCsC,GAAMJ,IAAM,CACVrB,IAAK,EACLD,KAAM,EACNb,MAAOX,EACPU,OAAQT,GAGViD,GAAMQ,MAAQ,CACZjC,IAAKtB,EACLqB,KAAMtB,EACNS,MAAOX,EAAiBE,EACxBQ,OAAQT,EAAkBE,GAI1B+C,GAAMJ,MACRE,GAAWrD,EAAU,CACnBK,eAAgBkD,GAAMJ,IAAInC,MAC1BV,gBAAiBiD,GAAMJ,IAAIpC,OAC3BR,WAAYgD,GAAMJ,IAAItB,KACtBrB,UAAW+C,GAAMJ,IAAIrB,IACrB1B,WAAY6B,EACZ1D,SAAU4D,EACV3D,SAAU0D,EACVzB,WAAY4B,EACZzD,SAAU6D,EACV5D,UAAW6D,EACX/B,aAAcgC,EACd7D,SAAQ,GACPkE,KAEDO,GAAMQ,QACRT,GAAatD,EAAU,CACrBK,eAAgBkD,GAAMQ,MAAM/C,MAC5BV,gBAAiBiD,GAAMQ,MAAMhD,OAC7BR,WAAYgD,GAAMQ,MAAMlC,KACxBrB,UAAW+C,GAAMQ,MAAMjC,IACvB1B,WAAU,EACV7B,SAAQ,EACRC,SAAQ,EACRiC,WAAY8C,GAAMJ,IAAMb,EAAkB7B,EAC1C7B,SAAU2E,GAAMJ,IAAMZ,EAAgB3D,EACtCC,UAAW0E,GAAMJ,IAAMX,EAAiB3D,EACxC8B,aAAY,EACZ7B,SAAQ,GACPsE,KAGL,IAAM/B,GAAe,GACjB2C,GAAc,EACdC,GAAgB,EAWpB,OATA/D,EAAS2D,SAAQ,SAAC/C,EAASoC,GACrBH,GAAWmB,QAAQhB,IAAQ,GAC7B7B,GAAM6B,GAAOG,GAASW,IACtBA,IAAe,IAEf3C,GAAM6B,GAAOI,GAAWW,IACxBA,IAAiB,MAGd,CAAE5C,MAAK,GAAEkC,MAAK,M;;;;;;;;;;qBCpdvB,WACA,OASAzH,EAAOD,QAAU,SAA6BsI,EAAkClE,GAC9E,IAAMmE,EAAOnE,GAAQA,EAAKoE,SAA8B,oBAAXA,YAAyBvE,EAAYuE,QASlF,OARAF,EAAiC,iBAAdA,EAAyBC,EAAIE,SAASC,cAAcJ,GAAaA,OAC1C,KAA5BC,GAAOA,EAAII,cAAgCL,aAAqBC,EAAII,aAAiBvE,EAGvFA,IACVA,EAAO,IAFPA,EAAOkE,EAKF,CACLM,OAAQ,UAAO3G,KAAK5B,KAAMiI,EAAWlE,GACrCD,UAAW,UAAUlC,KAAK5B,KAAM+D,M,qRCnCpC,WAEA,mBAAgBkE,EAAwBlE,GAItC,SAASyE,EAAIC,EAAiBC,EAA+CrH,GAC3E,GAA4B,iBAAjBqH,GAA6BrH,EAGtC,OADAoH,EAAGE,MAAMD,GAAgBrH,EAClBuH,IAET,GAA4B,iBAAjBF,EAKT,OAHA5H,OAAO+H,KAAKH,GAAcf,SAAQ,SAAChG,GACjC6G,EAAIC,EAAI9G,EAAK+G,EAAa/G,OAErBiH,IAGT,IACIE,GADoB/E,GAAQA,EAAKoE,QAAWA,QAAQY,iBAAiBN,GACxCO,iBAAiBN,GAMlD,MAJqB,KAAjBI,IACFA,EAAeL,EAAGE,MAAMD,IAGnBI,EAmBT,IA4EMG,EAAe,SAAsBC,EAAmBC,GAC5D,IAAMC,EAASZ,EAAIU,EAAMC,GACzB,OAAOC,EAASC,SAASD,EAAQ,IAAM,GAmBvC,EAIErF,EAAI,QAJNuF,OAAO,IAAG,GAAK,EACf,EAGEvF,EAAI,SAHNwF,OAAQ,IAAG,WAAQ,EACnB,EAEExF,EAAI,YAFNyF,OAAW,IAAG,cAAW,EACzB,EACEzF,EAAI,gBADN0F,OAAe,IAAG,kBAAe,EAGnC,GAAkC,SAA9BjB,EAAIP,EAAW,WAAnB,CAGA,IAxHgBQ,EAqGRiB,EAmBJC,EAAK1B,EAAU2B,aAAa,MAC3BD,IACHA,EAAK,cAzBmB,IAAhBpG,KAAKsG,UAAsBC,QAAQ,IA0B3C7B,EAAU8B,aAAa,KAAMJ,IAG/B5F,EAAKK,kBAzBGsF,GArGQjB,EA8HiBR,GA7HxB+B,aAAe,EACb,UAAGvB,EAAGuB,aAAY,MAEpBxB,EAAIC,EAAI,WAkGIY,SAASK,EAAW,IAAM,GAyB3CT,EAAahB,EAAW,cACxBgB,EAAahB,EAAW,iBAC5BlE,EAAKI,eAxBY,SAAkB+E,GACjC,IAnGaT,EAmGPwB,GAnGOxB,EAmGUS,GAlGhBgB,YAAc,EACZ,UAAGzB,EAAGyB,YAAW,MAEnB1B,EAAIC,EAAI,SAgGf,OAAOwB,EAAWZ,SAASY,EAAU,IAAM,EAsBvBE,CAASlC,GAC3BgB,EAAahB,EAAW,eACxBgB,EAAahB,EAAW,gBAE5B,IAAMmC,EAA0BC,MAAMrI,UAAU+E,OAAOxG,KACrD0H,EAAUqC,iBAAiB,WAAIX,EAAE,mBAAWH,EAAW,OAxI/B,SAAA5E,GAAW,MAA4B,SAA5B4D,EAAI5D,EAAS,cA2I5CZ,EAAsBoG,EAASzF,KAAI,SAACC,GACxC,OAAO,EAAP,KAtEmB,SAAsB2F,GACzC,GAAIA,EAAO,CACT,GAAKA,EAA2BC,aAAgBD,EAA2BE,WACzE,MAAO,CACL5F,OAAS0F,EAA2BC,YACpC1F,MAAQyF,EAA2BE,YAGvC,IAAMC,EAAQH,EAAMlC,cAAc,SAClC,GAAIqC,GAASA,EAAMF,aAAeE,EAAMD,WACtC,MAAO,CACL5F,OAAQ6F,EAAMF,YACd1F,MAAO4F,EAAMD,YAInB,MAAO,CACL5F,OAAQ,IACRC,MAAO,KAqDJ6F,CAAa/F,IAAQ,CACxBqC,IAAKrC,EAAQgG,UAAUC,SAAStB,GAChCrF,WAAYU,EAAQgG,UAAUC,SAASpB,SAI5B,aAAU1F,EAAMC,GACxBmB,MAAMwC,SAAQ,SAACC,EAAKZ,GACzB,IAAMkC,EAAOkB,EAASpD,GACtBwB,EAAIU,EAAM,WAAY,YACtB,IAAM4B,EAAclD,EAAI9C,MACpBmE,EAAaC,EAAM,eACnBD,EAAaC,EAAM,iBACU,eAA5BV,EAAIU,EAAM,cACRD,EAAaC,EAAM,gBAClBD,EAAaC,EAAM,iBACnBD,EAAaC,EAAM,eACnBD,EAAaC,EAAM,gBACrB,GAEA6B,EAAenD,EAAI/C,OACrBoE,EAAaC,EAAM,cACnBD,EAAaC,EAAM,kBACU,eAA5BV,EAAIU,EAAM,cACRD,EAAaC,EAAM,eAClBD,EAAaC,EAAM,kBACnBD,EAAaC,EAAM,cACnBD,EAAaC,EAAM,iBACrB,IAzJgB,SAAyBA,EAAmBjE,EAAWC,EAAW8F,EAAWC,EAAW3B,EAAkB4B,GAA1G,WAChBC,EAAiB,CACrBxF,KAAM,UAAGV,EAAC,MACVW,IAAK,UAAGV,EAAC,MACTJ,MAAO,UAAGkG,EAAC,MACXnG,OAAQ,UAAGoG,EAAC,OAGRG,EAAiB,WACrB,IAAMC,EAAMnC,EAAKb,cAAc,YAC/B,GAAIgD,EAAK,CAIP,IAAMC,EAAWD,EAAI1C,MAAM7D,MAC3BuG,EAAI1C,MAAM7D,MAAQ,UAAGkG,EAAC,MAEtBK,EAAI1C,MAAM7D,MAAQwG,GAAY,KAIlC,GAAIhC,GAAwB,oBAANiC,EAAmB,CACvCA,EAAErC,GAAMsC,OACR,IAAM,EAAgD,kBAAZlC,EAAwB,CAAEmC,SAAU,IAAKC,OAAQ,SAAYpC,EACvGiC,EAAErC,GAAMI,QAAQ6B,EAAgB,EAAaM,SAAU,EAAaC,QAClE,WACEN,IACI,EAAaO,UAAU,EAAaA,SAASpL,KAAK,GAClD2K,GACFA,EAAShC,EAAM,CACbvD,KAAMV,EACNW,IAAKV,EACLJ,MAAOkG,EACPnG,OAAQoG,YAKhBzC,EAAIU,EAAMiC,GACLjC,EAAK0B,UAAUC,SAAS,cAC3B3B,EAAK0B,UAAUgB,IAAI,aAEjBV,GACFA,EAAShC,EAAM,CACbvD,KAAMV,EACNW,IAAKV,EACLJ,MAAOkG,EACPnG,OAAQoG,IAIdG,IAwGAS,CAAgB3C,EAAMtB,EAAIjC,KAAMiC,EAAIhC,IAAKkF,EAAaC,EACpDzB,EAASvF,EAAKmH","file":"opentok-layout.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"initLayoutContainer\"] = factory();\n\telse\n\t\troot[\"initLayoutContainer\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","/// <reference path=\"../types/opentok-layout-js.d.ts\" />\n\nimport { Element, Options, Box, GetLayoutRes } from 'opentok-layout-js';\n\nconst getBestDimensions = (minRatio: number, maxRatio: number, Width: number, Height: number, count: number, maxWidth: number, maxHeight: number, evenRows: boolean) => {\n  let maxArea: number;\n  let targetCols: number;\n  let targetRows: number;\n  let targetHeight: number;\n  let targetWidth: number;\n  let tWidth: number;\n  let tHeight: number;\n  let tRatio: number;\n\n  // Iterate through every possible combination of rows and columns\n  // and see which one has the least amount of whitespace\n  for (let i = 1; i <= count; i += 1) {\n    const cols = i;\n    const rows = Math.ceil(count / cols);\n\n    // Try taking up the whole height and width\n    tHeight = Math.floor(Height / rows);\n    tWidth = Math.floor(Width / cols);\n\n    tRatio = tHeight / tWidth;\n    if (tRatio > maxRatio) {\n      // We went over decrease the height\n      tRatio = maxRatio;\n      tHeight = tWidth * tRatio;\n    } else if (tRatio < minRatio) {\n      // We went under decrease the width\n      tRatio = minRatio;\n      tWidth = tHeight / tRatio;\n    }\n\n    tWidth = Math.min(maxWidth, tWidth);\n    tHeight = Math.min(maxHeight, tHeight);\n\n    const area = (tWidth * tHeight) * count;\n\n    // If this width and height takes up the most space then we're going with that\n    if (maxArea === undefined || (area >= maxArea)) {\n      if (evenRows && area === maxArea && ((cols * rows) % count) > ((targetRows * targetCols) % count)) {\n        // We have the same area but there are more left over spots in the last row\n        // Let's keep the previous one\n        continue;\n      }\n      maxArea = area;\n      targetHeight = tHeight;\n      targetWidth = tWidth;\n      targetCols = cols;\n      targetRows = rows;\n    }\n  }\n  return {\n    maxArea,\n    targetCols,\n    targetRows,\n    targetHeight,\n    targetWidth,\n    ratio: targetHeight / targetWidth,\n  };\n};\n\ntype Offsets = {\n  offsetLeft: number;\n  offsetTop: number;\n}\n\ntype Row = {\n  ratios: number[];\n  elements: Element[];\n  width: number;\n  height: number;\n}\n\ntype Areas = { small?: Box, big?: Box }\n\nconst getLayout = (opts: Options & Offsets, elements: Element[]): Box[] => {\n  const {\n    maxRatio,\n    minRatio,\n    fixedRatio,\n    containerWidth,\n    containerHeight,\n    offsetLeft = 0,\n    offsetTop = 0,\n    alignItems = 'center',\n    maxWidth = Infinity,\n    maxHeight = Infinity,\n    scaleLastRow = true,\n    evenRows = true,\n  } = opts;\n  const ratios = elements.map(element => element.height / element.width);\n  const count = ratios.length;\n\n\n  let dimensions: ReturnType<typeof getBestDimensions>;\n\n  if (!fixedRatio) {\n    dimensions = getBestDimensions(minRatio, maxRatio, containerWidth, containerHeight, count,\n      maxWidth, maxHeight, evenRows);\n  } else {\n    // Use the ratio of the first video element we find to approximate\n    const ratio = ratios.length > 0 ? ratios[0] : null;\n    dimensions = getBestDimensions(ratio, ratio, containerWidth, containerHeight, count,\n      maxWidth, maxHeight, evenRows);\n  }\n\n  // Loop through each stream in the container and place it inside\n  let x = 0;\n  let y = 0;\n  const rows: Row[] = [];\n  let row: Row;\n  const boxes: Box[] = [];\n  // Iterate through the children and create an array with a new item for each row\n  // and calculate the width of each row so that we know if we go over the size and need\n  // to adjust\n  for (let i = 0; i < ratios.length; i += 1) {\n    if (i % dimensions.targetCols === 0) {\n      // This is a new row\n      row = {\n        ratios: [],\n        elements: [],\n        width: 0,\n        height: 0,\n      };\n      rows.push(row);\n    }\n    const ratio = ratios[i];\n    const element = elements[i];\n    row.elements.push(element);\n    row.ratios.push(ratio);\n    let targetWidth = dimensions.targetWidth;\n    const targetHeight = dimensions.targetHeight;\n    // If we're using a fixedRatio then we need to set the correct ratio for this element\n    if (fixedRatio || element.fixedRatio) {\n      targetWidth = targetHeight / ratio;\n    }\n    row.width += targetWidth;\n    row.height = targetHeight;\n  }\n  // Calculate total row height adjusting if we go too wide\n  let totalRowHeight = 0;\n  let remainingShortRows = 0;\n  for (let i = 0; i < rows.length; i += 1) {\n    row = rows[i];\n    if (row.width > containerWidth) {\n      // Went over on the width, need to adjust the height proportionally\n      row.height = Math.floor(row.height * (containerWidth / row.width));\n      row.width = containerWidth;\n    } else if (row.width < containerWidth && row.height < maxHeight) {\n      remainingShortRows += 1;\n    }\n    totalRowHeight += row.height;\n  }\n  if (scaleLastRow && totalRowHeight < containerHeight && remainingShortRows > 0) {\n    // We can grow some of the rows, we're not taking up the whole height\n    let remainingHeightDiff = containerHeight - totalRowHeight;\n    totalRowHeight = 0;\n    for (let i = 0; i < rows.length; i += 1) {\n      row = rows[i];\n      if (row.width < containerWidth) {\n        // Evenly distribute the extra height between the short rows\n        let extraHeight = remainingHeightDiff / remainingShortRows;\n        if ((extraHeight / row.height) > ((containerWidth - row.width) / row.width)) {\n          // We can't go that big or we'll go too wide\n          extraHeight = Math.floor(((containerWidth - row.width) / row.width) * row.height);\n        }\n        row.width += Math.floor((extraHeight / row.height) * row.width);\n        row.height += extraHeight;\n        remainingHeightDiff -= extraHeight;\n        remainingShortRows -= 1;\n      }\n      totalRowHeight += row.height;\n    }\n  }\n  switch (alignItems) {\n    case 'start':\n      y = 0;\n      break;\n    case 'end':\n      y = containerHeight - totalRowHeight;\n      break;\n    case 'center':\n    default:\n      y = ((containerHeight - (totalRowHeight)) / 2);\n      break;\n  }\n  // Iterate through each row and place each child\n  for (let i = 0; i < rows.length; i += 1) {\n    row = rows[i];\n    let rowMarginLeft;\n    switch (alignItems) {\n      case 'start':\n        rowMarginLeft = 0;\n        break;\n      case 'end':\n        rowMarginLeft = containerWidth - row.width;\n        break;\n      case 'center':\n      default:\n        rowMarginLeft = ((containerWidth - row.width) / 2);\n        break;\n    }\n    x = rowMarginLeft;\n    let targetHeight;\n    for (let j = 0; j < row.ratios.length; j += 1) {\n      const ratio = row.ratios[j];\n      const element = row.elements[j];\n\n      let targetWidth = dimensions.targetWidth;\n      targetHeight = row.height;\n      // If we're using a fixedRatio then we need to set the correct ratio for this element\n      if (fixedRatio || element.fixedRatio) {\n        targetWidth = Math.floor(targetHeight / ratio);\n      } else if ((targetHeight / targetWidth)\n        !== (dimensions.targetHeight / dimensions.targetWidth)) {\n        // We grew this row, we need to adjust the width to account for the increase in height\n        targetWidth = Math.floor((dimensions.targetWidth / dimensions.targetHeight) * targetHeight);\n      }\n\n      boxes.push({\n        left: x + offsetLeft,\n        top: y + offsetTop,\n        width: targetWidth,\n        height: targetHeight,\n      });\n      x += targetWidth;\n    }\n    y += targetHeight;\n  }\n  return boxes;\n};\n\nconst getVideoRatio = (element: Element) => element.height / element.width;\n\nexport default (opts: Options, elements: Element[]): GetLayoutRes => {\n  const {\n    maxRatio = 3 / 2,\n    minRatio = 9 / 16,\n    fixedRatio = false,\n    bigPercentage = 0.8,\n    minBigPercentage = 0,\n    bigFixedRatio = false,\n    bigMaxRatio = 3 / 2,\n    bigMinRatio = 9 / 16,\n    bigFirst = true,\n    containerWidth = 640,\n    containerHeight = 480,\n    alignItems = 'center',\n    bigAlignItems = 'center',\n    smallAlignItems = 'center',\n    maxWidth = Infinity,\n    maxHeight = Infinity,\n    smallMaxWidth = Infinity,\n    smallMaxHeight = Infinity,\n    bigMaxWidth = Infinity,\n    bigMaxHeight = Infinity,\n    scaleLastRow = true,\n    bigScaleLastRow = true,\n    evenRows = true,\n  } = opts;\n\n  const availableRatio = containerHeight / containerWidth;\n  let offsetLeft = 0;\n  let offsetTop = 0;\n  let bigOffsetTop = 0;\n  let bigOffsetLeft = 0;\n  const bigIndices: number[] = [];\n  const bigOnes = elements.filter((element, idx) => {\n    if (element.big) {\n      bigIndices.push(idx);\n      return true;\n    }\n    return false;\n  });\n  const smallOnes = elements.filter(element => !element.big);\n  let bigBoxes: Box[] = [];\n  let smallBoxes: Box[] = [];\n  const areas: Areas = {};\n  if (bigOnes.length > 0 && smallOnes.length > 0) {\n    let bigWidth: number;\n    let bigHeight: number;\n    let showBigFirst = bigFirst === true;\n\n    if (availableRatio > getVideoRatio(bigOnes[0])) {\n      // We are tall, going to take up the whole width and arrange small\n      // guys at the bottom\n      bigWidth = containerWidth;\n      bigHeight = Math.floor(containerHeight * bigPercentage);\n      if (minBigPercentage > 0) {\n        // Find the best size for the big area\n        let bigDimensions: ReturnType<typeof getBestDimensions>;\n        if (!bigFixedRatio) {\n          bigDimensions = getBestDimensions(bigMinRatio, bigMaxRatio, bigWidth,\n            bigHeight, bigOnes.length, bigMaxWidth, bigMaxHeight, evenRows);\n        } else {\n          // Use the ratio of the first video element we find to approximate\n          const ratio = bigOnes[0].height / bigOnes[0].width;\n          bigDimensions = getBestDimensions(ratio, ratio, bigWidth, bigHeight,\n            bigOnes.length, bigMaxWidth, bigMaxHeight, evenRows);\n        }\n        bigHeight = Math.max(containerHeight * minBigPercentage,\n          Math.min(bigHeight, bigDimensions.targetHeight * bigDimensions.targetRows));\n        // Don't awkwardly scale the small area bigger than we need to and end up with floating\n        // videos in the middle\n        const smallBoxes = getLayout({\n          containerWidth: containerWidth,\n          containerHeight: containerHeight - bigHeight,\n          offsetLeft: 0,\n          offsetTop: 0,\n          fixedRatio,\n          minRatio,\n          maxRatio,\n          alignItems: smallAlignItems,\n          maxWidth: smallMaxWidth,\n          maxHeight: smallMaxHeight,\n          scaleLastRow,\n          evenRows,\n        }, smallOnes);\n        let smallHeight = 0\n        let currentTop = undefined\n        smallBoxes.forEach(box => {\n          if (currentTop !== box.top) {\n            currentTop = box.top\n            smallHeight += box.height\n          }\n        })\n        bigHeight = Math.max(bigHeight, containerHeight - smallHeight);\n      }\n      offsetTop = bigHeight;\n      bigOffsetTop = containerHeight - offsetTop;\n      if (bigFirst === 'column') {\n        showBigFirst = false;\n      } else if (bigFirst === 'row') {\n        showBigFirst = true;\n      }\n    } else {\n      // We are wide, going to take up the whole height and arrange the small\n      // guys on the right\n      bigHeight = containerHeight;\n      bigWidth = Math.floor(containerWidth * bigPercentage);\n      if (minBigPercentage > 0) {\n        // Find the best size for the big area\n        let bigDimensions: ReturnType<typeof getBestDimensions>;\n        if (!bigFixedRatio) {\n          bigDimensions = getBestDimensions(bigMinRatio, bigMaxRatio, bigWidth,\n            bigHeight, bigOnes.length, bigMaxWidth, bigMaxHeight, evenRows);\n        } else {\n          // Use the ratio of the first video element we find to approximate\n          const ratio = bigOnes[0].height / bigOnes[0].width;\n          bigDimensions = getBestDimensions(ratio, ratio, bigWidth, bigHeight,\n            bigOnes.length, bigMaxWidth, bigMaxHeight, evenRows);\n        }\n        bigWidth = Math.max(containerWidth * minBigPercentage,\n          Math.min(bigWidth, bigDimensions.targetWidth * bigDimensions.targetCols));\n        // Don't awkwardly scale the small area bigger than we need to and end up with floating\n        // videos in the middle\n        const smallBoxes = getLayout({\n          containerWidth: containerWidth - bigWidth,\n          containerHeight: containerHeight,\n          offsetLeft: 0,\n          offsetTop: 0,\n          fixedRatio,\n          minRatio,\n          maxRatio,\n          alignItems: smallAlignItems,\n          maxWidth: smallMaxWidth,\n          maxHeight: smallMaxHeight,\n          scaleLastRow,\n          evenRows,\n        }, smallOnes);\n        let smallWidth = 0\n        let currentWidth = 0\n        let top = 0\n        smallBoxes.forEach(box => {\n          if (box.top !== top) {\n            currentWidth = 0\n            top = box.top\n          }\n          currentWidth += box.width\n          smallWidth = Math.max(smallWidth, currentWidth)\n        })\n        bigWidth = Math.max(bigWidth, containerWidth - smallWidth);\n      }\n      offsetLeft = bigWidth;\n      bigOffsetLeft = containerWidth - offsetLeft;\n      if (bigFirst === 'column') {\n        showBigFirst = true;\n      } else if (bigFirst === 'row') {\n        showBigFirst = false;\n      }\n    }\n    if (showBigFirst) {\n      areas.big = {\n        top: 0,\n        left: 0,\n        width: bigWidth,\n        height: bigHeight,\n      };\n      areas.small = {\n        top: offsetTop,\n        left: offsetLeft,\n        width: containerWidth - offsetLeft,\n        height: containerHeight - offsetTop,\n      };\n    } else {\n      areas.big = {\n        left: bigOffsetLeft,\n        top: bigOffsetTop,\n        width: bigWidth,\n        height: bigHeight,\n      };\n      areas.small = {\n        top: 0,\n        left: 0,\n        width: containerWidth - offsetLeft,\n        height: containerHeight - offsetTop,\n      };\n    }\n  } else if (bigOnes.length > 0 && smallOnes.length === 0) {\n    // We only have one bigOne just center it\n    areas.big = {\n      top: 0,\n      left: 0,\n      width: containerWidth,\n      height: containerHeight,\n    };\n  } else {\n    areas.small = {\n      top: offsetTop,\n      left: offsetLeft,\n      width: containerWidth - offsetLeft,\n      height: containerHeight - offsetTop,\n    };\n  }\n\n  if (areas.big) {\n    bigBoxes = getLayout({\n      containerWidth: areas.big.width,\n      containerHeight: areas.big.height,\n      offsetLeft: areas.big.left,\n      offsetTop: areas.big.top,\n      fixedRatio: bigFixedRatio,\n      minRatio: bigMinRatio,\n      maxRatio: bigMaxRatio,\n      alignItems: bigAlignItems,\n      maxWidth: bigMaxWidth,\n      maxHeight: bigMaxHeight,\n      scaleLastRow: bigScaleLastRow,\n      evenRows,\n    }, bigOnes);\n  }\n  if (areas.small) {\n    smallBoxes = getLayout({\n      containerWidth: areas.small.width,\n      containerHeight: areas.small.height,\n      offsetLeft: areas.small.left,\n      offsetTop: areas.small.top,\n      fixedRatio,\n      minRatio,\n      maxRatio,\n      alignItems: areas.big ? smallAlignItems : alignItems,\n      maxWidth: areas.big ? smallMaxWidth : maxWidth,\n      maxHeight: areas.big ? smallMaxHeight : maxHeight,\n      scaleLastRow,\n      evenRows,\n    }, smallOnes);\n  }\n\n  const boxes: Box[] = [];\n  let bigBoxesIdx = 0;\n  let smallBoxesIdx = 0;\n  // Rebuild the array in the right order based on where the bigIndices should be\n  elements.forEach((element, idx) => {\n    if (bigIndices.indexOf(idx) > -1) {\n      boxes[idx] = bigBoxes[bigBoxesIdx];\n      bigBoxesIdx += 1;\n    } else {\n      boxes[idx] = smallBoxes[smallBoxesIdx];\n      smallBoxesIdx += 1;\n    }\n  });\n  return { boxes, areas };\n};\n","/// <reference path=\"../types/opentok-layout-js.d.ts\" />\n/*!\n *  opentok-layout-js (http://github.com/aullman/opentok-layout-js)\n *\n *  Automatic layout of video elements (publisher and subscriber) minimising\n *  white-space for the OpenTok on WebRTC API.\n *\n *  @Author: Adam Ullman (http://github.com/aullman)\n *  @Copyright (c) 2014 Adam Ullman\n *  @License: Released under the MIT license (http://opensource.org/licenses/MIT)\n * */\n\n// in CommonJS context, this should be a `require()`d dependency.\n// in browser globals context, ...? (when using bower, there are dependencies that it has handled\n// for you, so these might be safe to assume)\n\nimport getLayout from './getLayout'\nimport layout from './layout'\nimport type { Options, LayoutContainer } from 'opentok-layout-js'\n\ndeclare global {\n  interface Window {\n    HTMLElement: typeof HTMLElement;\n  }\n}\n\nmodule.exports = function initLayoutContainer(container: HTMLElement | Options, opts: Options): LayoutContainer {\n  const win = (opts && opts.window) || (typeof window === 'undefined' ? undefined : window);\n  container = typeof container === 'string' ? win.document.querySelector(container) : container;\n  if (!(typeof (win && win.HTMLElement) === 'undefined' || container instanceof win.HTMLElement) && !opts) {\n    // container is actually the options\n    opts = container as Options;\n  } else if (!opts) {\n    opts = {};\n  }\n\n  return {\n    layout: layout.bind(this, container, opts),\n    getLayout: getLayout.bind(this, opts),\n  };\n};\n","/// <reference path=\"../types/opentok-layout-js.d.ts\" />\n\nimport { Options, Element, OnLayout, Animate, AnimateProps } from 'opentok-layout-js';\nimport getLayout from './getLayout';\n\nexport default (container: HTMLElement, opts: Options) => {\n  function css(el: HTMLElement, propertyName: Record<string, string>): typeof NaN\n  function css(el: HTMLElement, propertyName: string, value: string): typeof NaN\n  function css(el: HTMLElement, propertyName: string): string\n  function css(el: HTMLElement, propertyName: string | Record<string, string>, value?: string) {\n    if (typeof propertyName === 'string' && value) {\n      // We are setting one css property\n      el.style[propertyName] = value;\n      return NaN;\n    }\n    if (typeof propertyName === 'object') {\n      // We are setting several CSS properties at once\n      Object.keys(propertyName).forEach((key) => {\n        css(el, key, propertyName[key]);\n      });\n      return NaN;\n    }\n    // We are getting the css property\n    const computedStyle = ((opts && opts.window) || window).getComputedStyle(el);\n    let currentValue = computedStyle.getPropertyValue(propertyName);\n\n    if (currentValue === '') {\n      currentValue = el.style[propertyName];\n    }\n\n    return currentValue;\n  }\n\n  const filterDisplayNone = element => css(element, 'display') !== 'none';\n\n  function height(el) {\n    if (el.offsetHeight > 0) {\n      return `${el.offsetHeight}px`;\n    }\n    return css(el, 'height');\n  }\n\n  function width(el) {\n    if (el.offsetWidth > 0) {\n      return `${el.offsetWidth}px`;\n    }\n    return css(el, 'width');\n  }\n\n  const positionElement = function positionElement(elem: HTMLElement, x: number, y: number, w: number, h: number, animate: Animate, onLayout: OnLayout) {\n    const targetPosition = {\n      left: `${x}px`,\n      top: `${y}px`,\n      width: `${w}px`,\n      height: `${h}px`,\n    };\n\n    const fixAspectRatio = function fixAspectRatio() {\n      const sub = elem.querySelector('.OT_root') as HTMLElement;\n      if (sub) {\n        // If this is the parent of a subscriber or publisher then we need\n        // to force the mutation observer on the publisher or subscriber to\n        // trigger to get it to fix it's layout\n        const oldWidth = sub.style.width;\n        sub.style.width = `${w}px`;\n        // sub.style.height = height + 'px';\n        sub.style.width = oldWidth || '';\n      }\n    };\n\n    if (animate && typeof $ !== 'undefined') {\n      $(elem).stop();\n      const animateProps: AnimateProps = typeof animate === 'boolean' ? { duration: 200, easing: 'swing' } : animate;\n      $(elem).animate(targetPosition, animateProps.duration, animateProps.easing,\n        () => {\n          fixAspectRatio();\n          if (animateProps.complete) animateProps.complete.call(this);\n          if (onLayout) {\n            onLayout(elem, {\n              left: x,\n              top: y,\n              width: w,\n              height: h,\n            });\n          }\n        });\n    } else {\n      css(elem, targetPosition);\n      if (!elem.classList.contains('ot-layout')) {\n        elem.classList.add('ot-layout');\n      }\n      if (onLayout) {\n        onLayout(elem, {\n          left: x,\n          top: y,\n          width: w,\n          height: h,\n        });\n      }\n    }\n    fixAspectRatio();\n  };\n\n  const getChildDims = function getChildDims(child: HTMLVideoElement | HTMLElement): Omit<Element, 'big'> {\n    if (child) {\n      if ((child as HTMLVideoElement).videoHeight && (child as HTMLVideoElement).videoWidth) {\n        return {\n          height: (child as HTMLVideoElement).videoHeight,\n          width: (child as HTMLVideoElement).videoWidth,\n        };\n      }\n      const video = child.querySelector('video');\n      if (video && video.videoHeight && video.videoWidth) {\n        return {\n          height: video.videoHeight,\n          width: video.videoWidth,\n        };\n      }\n    }\n    return {\n      height: 480,\n      width: 640,\n    };\n  };\n\n  const getCSSNumber = function getCSSNumber(elem: HTMLElement, prop: string) {\n    const cssStr = css(elem, prop);\n    return cssStr ? parseInt(cssStr, 10) : 0;\n  };\n\n  // Really cheap UUID function\n  const cheapUUID = function cheapUUID() {\n    return (Math.random() * 100000000).toFixed(0);\n  };\n\n  const getHeight = function getHeight(elem) {\n    const heightStr = height(elem);\n    return heightStr ? parseInt(heightStr, 10) : 0;\n  };\n\n  const getWidth = function getWidth(elem) {\n    const widthStr = width(elem);\n    return widthStr ? parseInt(widthStr, 10) : 0;\n  };\n\n  const {\n    animate = false,\n    bigClass = 'OT_big',\n    ignoreClass = 'OT_ignore',\n    fixedRatioClass = 'OT_fixedRatio',\n  } = opts;\n\n  if (css(container, 'display') === 'none') {\n    return;\n  }\n  let id = container.getAttribute('id');\n  if (!id) {\n    id = `OT_${cheapUUID()}`;\n    container.setAttribute('id', id);\n  }\n\n  opts.containerHeight = getHeight(container)\n    - getCSSNumber(container, 'border-top')\n    - getCSSNumber(container, 'border-bottom');\n  opts.containerWidth = getWidth(container)\n    - getCSSNumber(container, 'border-left')\n    - getCSSNumber(container, 'border-right');\n\n  const children: HTMLElement[] = Array.prototype.filter.call(\n    container.querySelectorAll(`#${id}>*:not(.${ignoreClass})`),\n    filterDisplayNone\n  );\n  const elements: Element[] = children.map((element) => {\n    return {\n      ...getChildDims(element),\n      big: element.classList.contains(bigClass),\n      fixedRatio: element.classList.contains(fixedRatioClass),\n    };\n  });\n\n  const layout = getLayout(opts, elements);\n  layout.boxes.forEach((box, idx) => {\n    const elem = children[idx];\n    css(elem, 'position', 'absolute');\n    const actualWidth = box.width\n      - getCSSNumber(elem, 'margin-left')\n      - getCSSNumber(elem, 'margin-right')\n      - (css(elem, 'box-sizing') !== 'border-box'\n        ? (getCSSNumber(elem, 'padding-left')\n          + getCSSNumber(elem, 'padding-right')\n          + getCSSNumber(elem, 'border-left')\n          + getCSSNumber(elem, 'border-right'))\n        : 0);\n\n    const actualHeight = box.height\n      - getCSSNumber(elem, 'margin-top')\n      - getCSSNumber(elem, 'margin-bottom')\n      - (css(elem, 'box-sizing') !== 'border-box'\n        ? (getCSSNumber(elem, 'padding-top')\n          + getCSSNumber(elem, 'padding-bottom')\n          + getCSSNumber(elem, 'border-top')\n          + getCSSNumber(elem, 'border-bottom'))\n        : 0);\n\n    positionElement(elem, box.left, box.top, actualWidth, actualHeight,\n      animate, opts.onLayout);\n  });\n};\n"],"sourceRoot":""}